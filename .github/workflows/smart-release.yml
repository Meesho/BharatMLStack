name: Smart Release Management

on:
  push:
    branches: 
      - master
      - main
      - develop
      - 'release-*'
  pull_request:
    types: [closed]
    branches:
      - master
      - main
      - develop
      - 'release-*'

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/${{ github.repository_owner }}
  PLATFORMS: linux/amd64,linux/arm64

jobs:
  detect-release-info:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    outputs:
      should-release: ${{ steps.check-branch.outputs.should-release }}
      version-increment: ${{ steps.check-branch.outputs.version-increment }}
      is-beta: ${{ steps.check-branch.outputs.is-beta }}
      target-branch: ${{ steps.check-branch.outputs.target-branch }}
      source-branch: ${{ steps.check-branch.outputs.source-branch }}
      horizon-changed: ${{ steps.changes.outputs.horizon }}
      trufflebox-ui-changed: ${{ steps.changes.outputs.trufflebox-ui }}
      online-feature-store-changed: ${{ steps.changes.outputs.online-feature-store }}
      go-sdk-changed: ${{ steps.changes.outputs.go-sdk }}
      py-sdk-changed: ${{ steps.changes.outputs.py-sdk }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for changes
        uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            horizon:
              - 'horizon/**'
            trufflebox-ui:
              - 'trufflebox-ui/**'
            online-feature-store:
              - 'online-feature-store/**'
            go-sdk:
              - 'go-sdk/**'
            py-sdk:
              - 'py-sdk/**'

      - name: Determine release strategy
        id: check-branch
        run: |
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          
          # Initialize outputs
          SHOULD_RELEASE="false"
          VERSION_INCREMENT="none"
          IS_BETA="false"
          TARGET_BRANCH=""
          SOURCE_BRANCH=""
          
          if [ "${{ github.event_name }}" == "push" ]; then
            # Direct push to branch
            TARGET_BRANCH="${{ github.ref_name }}"
            echo "Direct push to $TARGET_BRANCH"
            
            if [ "$TARGET_BRANCH" == "develop" ]; then
              IS_BETA="true"
              echo "Develop branch - will create beta release"
            fi
          elif [ "${{ github.event_name }}" == "pull_request" ] && [ "${{ github.event.pull_request.merged }}" == "true" ]; then
            # PR was merged
            TARGET_BRANCH="${{ github.event.pull_request.base.ref }}"
            SOURCE_BRANCH_FULL="${{ github.event.pull_request.head.ref }}"
            SOURCE_BRANCH=$(echo "$SOURCE_BRANCH_FULL" | cut -d'/' -f1)
            
            echo "PR merged from $SOURCE_BRANCH_FULL into $TARGET_BRANCH"
            echo "Source branch prefix: $SOURCE_BRANCH"
            
            # Check if target branch is one we care about
            if [[ "$TARGET_BRANCH" =~ ^(master|main|develop|release-.*)$ ]]; then
              case "$SOURCE_BRANCH" in
                "feat")
                  SHOULD_RELEASE="true"
                  VERSION_INCREMENT="minor"
                  echo "Feature branch merged - will increment minor version"
                  ;;
                "fix")
                  SHOULD_RELEASE="true"
                  VERSION_INCREMENT="patch"
                  echo "Fix branch merged - will increment patch version"
                  ;;
                "feat-nbc")
                  SHOULD_RELEASE="true"
                  VERSION_INCREMENT="major"
                  echo "Breaking feature branch merged - will increment major version"
                  ;;
                *)
                  echo "Branch prefix '$SOURCE_BRANCH' doesn't trigger release"
                  ;;
              esac
              
              if [ "$TARGET_BRANCH" == "develop" ]; then
                IS_BETA="true"
                echo "Target is develop branch - will create beta release"
              fi
            else
              echo "Target branch '$TARGET_BRANCH' doesn't support releases"
            fi
          fi
          
          echo "should-release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "version-increment=$VERSION_INCREMENT" >> $GITHUB_OUTPUT
          echo "is-beta=$IS_BETA" >> $GITHUB_OUTPUT
          echo "target-branch=$TARGET_BRANCH" >> $GITHUB_OUTPUT
          echo "source-branch=$SOURCE_BRANCH" >> $GITHUB_OUTPUT
          
          echo "Final decision:"
          echo "  Should Release: $SHOULD_RELEASE"
          echo "  Version Increment: $VERSION_INCREMENT"
          echo "  Is Beta: $IS_BETA"
          echo "  Target Branch: $TARGET_BRANCH"
          echo "  Source Branch: $SOURCE_BRANCH"

  update-versions:
    needs: detect-release-info
    if: needs.detect-release-info.outputs.should-release == 'true' || needs.detect-release-info.outputs.is-beta == 'true'
    runs-on: ubuntu-latest
    outputs:
      updated-versions: ${{ steps.bump-versions.outputs.updated-versions }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Bump versions
        id: bump-versions
        run: |
          # Function to increment version
          increment_version() {
            local version=$1
            local increment_type=$2
            
            # Remove 'v' prefix if present
            version=${version#v}
            
            # Split version into parts
            IFS='.' read -ra PARTS <<< "$version"
            major=${PARTS[0]:-0}
            minor=${PARTS[1]:-0}
            patch=${PARTS[2]:-0}
            
            case "$increment_type" in
              "major")
                major=$((major + 1))
                minor=0
                patch=0
                ;;
              "minor")
                minor=$((minor + 1))
                patch=0
                ;;
              "patch")
                patch=$((patch + 1))
                ;;
            esac
            
            echo "v$major.$minor.$patch"
          }
          
          # Collect updated versions
          UPDATED_VERSIONS=""
          
          VERSION_INCREMENT="${{ needs.detect-release-info.outputs.version-increment }}"
          IS_BETA="${{ needs.detect-release-info.outputs.is-beta }}"
          COMMIT_SHA="${{ github.sha }}"
          SHORT_SHA=${COMMIT_SHA:0:8}
          
          # Define directories with VERSION files
          DIRS=("horizon" "trufflebox-ui" "online-feature-store" "go-sdk" "py-sdk/bharatml_commons" "py-sdk/spark_feature_push_client" "py-sdk/grpc_feature_client")
          
          for dir in "${DIRS[@]}"; do
            if [ -f "$dir/VERSION" ]; then
              current_version=$(cat "$dir/VERSION" | tr -d '\n' | tr -d ' ')
              
              if [ "$VERSION_INCREMENT" != "none" ] && [ "$IS_BETA" != "true" ]; then
                # Increment version for non-beta releases
                new_version=$(increment_version "$current_version" "$VERSION_INCREMENT")
                echo "$new_version" > "$dir/VERSION"
                echo "Updated $dir/VERSION: $current_version -> $new_version"
                UPDATED_VERSIONS="$UPDATED_VERSIONS$dir:$new_version;"
              elif [ "$IS_BETA" == "true" ]; then
                # For beta releases, use current version with beta suffix
                base_version=${current_version#v}
                beta_version="v${base_version}-beta.sha${SHORT_SHA}"
                echo "Beta version for $dir: $beta_version (VERSION file unchanged)"
                UPDATED_VERSIONS="$UPDATED_VERSIONS$dir:$beta_version;"
              fi
            fi
          done
          
          # Commit version changes if any were made
          if [ "$VERSION_INCREMENT" != "none" ] && [ "$IS_BETA" != "true" ]; then
            git add -A
            if ! git diff --cached --quiet; then
              git commit -m "chore: bump versions ($VERSION_INCREMENT increment) [skip ci]"
              git push origin ${{ needs.detect-release-info.outputs.target-branch }}
              echo "Committed and pushed version updates"
            fi
          fi
          
          echo "updated-versions=$UPDATED_VERSIONS" >> $GITHUB_OUTPUT

  release-py-sdk:
    needs: [detect-release-info, update-versions]
    if: (needs.detect-release-info.outputs.should-release == 'true' || needs.detect-release-info.outputs.is-beta == 'true') && needs.detect-release-info.outputs.py-sdk-changed == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Determine versions
        id: versions
        run: |
          # Extract versions from updated-versions output
          UPDATED_VERSIONS="${{ needs.update-versions.outputs.updated-versions }}"
          COMMIT_SHA="${{ github.sha }}"
          SHORT_SHA=${COMMIT_SHA:0:8}
          IS_BETA="${{ needs.detect-release-info.outputs.is-beta }}"
          
          # Function to get version for a component
          get_version() {
            local component=$1
            local version=$(echo "$UPDATED_VERSIONS" | grep -o "${component}:[^;]*" | cut -d':' -f2)
            if [ -z "$version" ]; then
              # Fallback to VERSION file
              if [ -f "${component}/VERSION" ]; then
                version=$(cat "${component}/VERSION" | tr -d '\n' | tr -d ' ')
                if [ "$IS_BETA" == "true" ]; then
                  base_version=${version#v}
                  version="v${base_version}-beta.sha${SHORT_SHA}"
                fi
              else
                version="latest"
              fi
            fi
            echo "$version"
          }
          
          BHARATML_VERSION=$(get_version "py-sdk/bharatml_commons")
          SPARK_VERSION=$(get_version "py-sdk/spark_feature_push_client")
          GRPC_VERSION=$(get_version "py-sdk/grpc_feature_client")
          
          # Strip 'v' prefix for PyPI
          BHARATML_VERSION=${BHARATML_VERSION#v}
          SPARK_VERSION=${SPARK_VERSION#v}
          GRPC_VERSION=${GRPC_VERSION#v}
          
          echo "bharatml_version=$BHARATML_VERSION" >> $GITHUB_OUTPUT
          echo "spark_version=$SPARK_VERSION" >> $GITHUB_OUTPUT
          echo "grpc_version=$GRPC_VERSION" >> $GITHUB_OUTPUT
          
          echo "bharatml-commons version: $BHARATML_VERSION"
          echo "spark-feature-push-client version: $SPARK_VERSION"
          echo "grpc-feature-client version: $GRPC_VERSION"

      - name: Build all packages
        run: |
          mkdir -p dist
          rm -rf dist/*
          
          cd py-sdk/bharatml_commons
          rm -rf dist/ build/ *.egg-info/
          python -m build
          cp dist/* ../../dist/
          cd ../..
          
          cd py-sdk/spark_feature_push_client
          rm -rf dist/ build/ *.egg-info/
          python -m build
          cp dist/* ../../dist/
          cd ../..
          
          cd py-sdk/grpc_feature_client
          rm -rf dist/ build/ *.egg-info/
          python -m build
          cp dist/* ../../dist/
          cd ../..
          
          echo "ðŸ“¦ Built packages:"
          ls -la dist/

      - name: Test package installations
        run: |
          pip install dist/*.whl --force-reinstall --find-links dist/
          python -c "
          import bharatml_commons
          import spark_feature_push_client
          import grpc_feature_client
          print('âœ“ All packages imported successfully')
          "

      - name: Publish to TestPyPI (beta/develop)
        if: needs.detect-release-info.outputs.is-beta == 'true'
        run: |
          twine upload --repository testpypi dist/*
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.TEST_PYPI_API_TOKEN }}

      - name: Publish to PyPI (production release)
        if: needs.detect-release-info.outputs.is-beta != 'true'
        run: |
          twine upload dist/*
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}

  build-and-push-images:
    needs: [detect-release-info, update-versions]
    if: needs.detect-release-info.outputs.should-release == 'true' || needs.detect-release-info.outputs.is-beta == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        component: [
          {name: "horizon", dockerfile: "cmd/horizon/Dockerfile", changed: "${{ needs.detect-release-info.outputs.horizon-changed }}"},
          {name: "onfs-api-server", dockerfile: "cmd/api-server/DockerFile", path: "online-feature-store", changed: "${{ needs.detect-release-info.outputs.online-feature-store-changed }}"},
          {name: "onfs-consumer", dockerfile: "cmd/consumer/DockerFile", path: "online-feature-store", changed: "${{ needs.detect-release-info.outputs.online-feature-store-changed }}"},
          {name: "trufflebox-ui", dockerfile: "DockerFile", changed: "${{ needs.detect-release-info.outputs.trufflebox-ui-changed }}"}
        ]
    steps:
      - name: Skip if component unchanged
        if: matrix.component.changed != 'true'
        run: |
          echo "Skipping ${{ matrix.component.name }} - no changes detected"
          exit 0

      - name: Checkout repository
        if: matrix.component.changed == 'true'
        uses: actions/checkout@v4

      - name: Set up buildx builder
        if: matrix.component.changed == 'true'
        run: |
          if ! docker buildx inspect multiarch-builder &>/dev/null; then
            echo "ðŸ”§ Creating buildx builder 'multiarch-builder'..."
            docker buildx create --name multiarch-builder --use
            docker buildx inspect --bootstrap
          else
            docker buildx use multiarch-builder
          fi

      - name: Determine version
        if: matrix.component.changed == 'true'
        id: version
        run: |
          UPDATED_VERSIONS="${{ needs.update-versions.outputs.updated-versions }}"
          COMMIT_SHA="${{ github.sha }}"
          SHORT_SHA=${COMMIT_SHA:0:8}
          IS_BETA="${{ needs.detect-release-info.outputs.is-beta }}"
          
          # Map component name to directory
          case "${{ matrix.component.name }}" in
            "horizon")
              VERSION_DIR="horizon"
              ;;
            "onfs-api-server"|"onfs-consumer")
              VERSION_DIR="online-feature-store"
              ;;
            "trufflebox-ui")
              VERSION_DIR="trufflebox-ui"
              ;;
          esac
          
          # Get version from updated versions or fallback to VERSION file
          VERSION=$(echo "$UPDATED_VERSIONS" | grep -o "${VERSION_DIR}:[^;]*" | cut -d':' -f2)
          if [ -z "$VERSION" ]; then
            if [ -f "${VERSION_DIR}/VERSION" ]; then
              VERSION=$(cat "${VERSION_DIR}/VERSION" | tr -d '\n' | tr -d ' ')
              if [ "$IS_BETA" == "true" ]; then
                base_version=${VERSION#v}
                VERSION="v${base_version}-beta.sha${SHORT_SHA}"
              fi
            else
              VERSION="latest"
            fi
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Using version: $VERSION for ${{ matrix.component.name }}"

      - name: Log in to Container Registry
        if: matrix.component.changed == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        if: matrix.component.changed == 'true'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_PREFIX }}/${{ matrix.component.name }}
          tags: |
            type=raw,value=${{ steps.version.outputs.version }}
            type=raw,value=latest,enable=${{ needs.detect-release-info.outputs.is-beta != 'true' && contains(fromJSON('["master", "main"]'), needs.detect-release-info.outputs.target-branch) }}

      - name: Build and push Docker image
        if: matrix.component.changed == 'true'
        run: |
          WORK_DIR="${{ matrix.component.path || matrix.component.name }}"
          cd "$WORK_DIR"
          
          BUILD_CMD="docker buildx build \
            --platform ${{ env.PLATFORMS }} \
            -f ${{ matrix.component.dockerfile }}"
          
          IFS=$'\n' read -rd '' -a tag_array <<< "${{ steps.meta.outputs.tags }}" || true
          for tag in "${tag_array[@]}"; do
            if [[ -n "$tag" ]]; then
              BUILD_CMD+=" -t \"$tag\""
            fi
          done
          
          IFS=$'\n' read -rd '' -a label_array <<< "${{ steps.meta.outputs.labels }}" || true
          for label in "${label_array[@]}"; do
            if [[ -n "$label" ]]; then
              BUILD_CMD+=" --label \"$label\""
            fi
          done
          
          BUILD_CMD+=" --push ."
          
          echo "Running: $BUILD_CMD"
          eval $BUILD_CMD

  release-go-sdk:
    needs: [detect-release-info, update-versions]
    if: (needs.detect-release-info.outputs.should-release == 'true' || needs.detect-release-info.outputs.is-beta == 'true') && needs.detect-release-info.outputs.go-sdk-changed == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Get version
        id: version
        run: |
          UPDATED_VERSIONS="${{ needs.update-versions.outputs.updated-versions }}"
          VERSION=$(echo "$UPDATED_VERSIONS" | grep -o "go-sdk:[^;]*" | cut -d':' -f2)
          if [ -z "$VERSION" ]; then
            VERSION=$(cat go-sdk/VERSION | tr -d '\n' | tr -d ' ')
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Go SDK version: $VERSION"

      - name: Create Git tag
        if: needs.detect-release-info.outputs.is-beta != 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          TAG="go-sdk/${{ steps.version.outputs.version }}"
          git tag -a "$TAG" -m "Go SDK release ${{ steps.version.outputs.version }}"
          git push origin "$TAG"

      - name: Build and test
        run: |
          cd go-sdk
          go mod tidy
          go build ./...
          go test ./...

  generate-release-summary:
    needs: [detect-release-info, update-versions, release-py-sdk, build-and-push-images, release-go-sdk]
    if: always() && (needs.detect-release-info.outputs.should-release == 'true' || needs.detect-release-info.outputs.is-beta == 'true')
    runs-on: ubuntu-latest
    steps:
      - name: Generate comprehensive summary
        run: |
          echo "## ðŸš€ Smart Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Source Branch:** ${{ needs.detect-release-info.outputs.source-branch }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target Branch:** ${{ needs.detect-release-info.outputs.target-branch }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version Increment:** ${{ needs.detect-release-info.outputs.version-increment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Beta Release:** ${{ needs.detect-release-info.outputs.is-beta }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ðŸ“¦ Components Released:" >> $GITHUB_STEP_SUMMARY
          
          UPDATED_VERSIONS="${{ needs.update-versions.outputs.updated-versions }}"
          if [ -n "$UPDATED_VERSIONS" ]; then
            echo "| Component | Version | Status |" >> $GITHUB_STEP_SUMMARY
            echo "|-----------|---------|--------|" >> $GITHUB_STEP_SUMMARY
            
            IFS=';' read -ra VERSIONS <<< "$UPDATED_VERSIONS"
            for version_info in "${VERSIONS[@]}"; do
              if [ -n "$version_info" ]; then
                IFS=':' read -ra PARTS <<< "$version_info"
                component=${PARTS[0]}
                version=${PARTS[1]}
                echo "| $component | \`$version\` | âœ… Released |" >> $GITHUB_STEP_SUMMARY
              fi
            done
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŽ¯ Release Strategy Applied:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.detect-release-info.outputs.is-beta }}" == "true" ]; then
            echo "- **Beta Release**: Versions include \`-beta.sha[commit]\` suffix" >> $GITHUB_STEP_SUMMARY
            echo "- **PyPI**: Published to TestPyPI" >> $GITHUB_STEP_SUMMARY
            echo "- **Docker**: Images tagged with beta version" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Production Release**: Clean version numbers" >> $GITHUB_STEP_SUMMARY
            echo "- **PyPI**: Published to production PyPI" >> $GITHUB_STEP_SUMMARY
            echo "- **Docker**: Images tagged with release version + latest" >> $GITHUB_STEP_SUMMARY
            echo "- **Git**: Tags created for Go SDK" >> $GITHUB_STEP_SUMMARY
          fi 