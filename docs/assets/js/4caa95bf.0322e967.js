"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[344],{340:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/v1.0.0-psdb-anatomy-c1735559f93dce6d0bb3894d16047059.png"},1729:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/v1.0.0-psdb-bool-encoding-4b154fdf5e6d79a67c91b6fb21c7209e.png"},4040:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/v1.0.0-csdb-skip-read-e3926080f7341aa7d3c6ec6d8274ea14.png"},8453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>l});var s=i(6540);const t={},r=s.createContext(t);function d(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),s.createElement(r.Provider,{value:n},e.children)}},9106:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/v1.0.0-psdb-fixed-length-encodding-dd252110b084e01cf38f21de16b3a1a5.png"},9432:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/v1.0.0-psdb-string-encoding-b1d69e9452269124d1b545020fa27d63.png"},9584:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"online-feature-store/v1.0.0/data-formats","title":"Data Formats","description":"In this section we will go through the data-formats which is at the hear of online-feature-store, it\'s inspired form other storage efficient formats like parquet & arrow, but custom made to deliver in constraint environment. The two key data-formats are:","source":"@site/docs/online-feature-store/v1.0.0/data-formats.md","sourceDirName":"online-feature-store/v1.0.0","slug":"/online-feature-store/v1.0.0/data-formats","permalink":"/bharatmlstack/online-feature-store/v1.0.0/data-formats","draft":false,"unlisted":false,"editUrl":"https://github.com/Meesho/BharatMLStack/tree/main/docs/docs/online-feature-store/v1.0.0/data-formats.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Data Formats","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Architecture","permalink":"/bharatmlstack/online-feature-store/v1.0.0/architecture"},"next":{"title":"Benchmarks","permalink":"/bharatmlstack/online-feature-store/v1.0.0/benchmarks"}}');var t=i(4848),r=i(8453);const d={title:"Data Formats",sidebar_position:2},l="Data Format for Permanent & Cache Storage",c={},a=[{value:"PSDB (Permanent Storage Data Block) Format",id:"psdb-permanent-storage-data-block-format",level:2},{value:"\ud83e\uddf1 Structure Overview",id:"-structure-overview",level:3},{value:"Supported Data Types",id:"supported-data-types",level:3},{value:"Scalar Types",id:"scalar-types",level:4},{value:"Vector Types",id:"vector-types",level:4},{value:"\ud83d\udce6 Encoding for Scalar Feature Type",id:"-encoding-for-scalar-feature-type",level:3},{value:"1. \ud83d\udd21 String Feature Group (Variable Length Encoding using Pascal)",id:"1--string-feature-group-variable-length-encoding-using-pascal",level:4},{value:"2. \ud83d\udfe9 Boolean Feature Group (Bit-Packed)",id:"2--boolean-feature-group-bit-packed",level:4},{value:"3. \ud83d\udccf Fixed-Length Feature Group",id:"3--fixed-length-feature-group",level:4},{value:"4. Compression",id:"4-compression",level:4},{value:"\ud83e\uddec Encoding for Vector Types",id:"-encoding-for-vector-types",level:3},{value:"Conceptual Overview",id:"conceptual-overview",level:4},{value:"Vector Length Metadata",id:"vector-length-metadata",level:4},{value:"Encoding Process",id:"encoding-process",level:4},{value:"<strong>Input Structure</strong>",id:"input-structure",level:5},{value:"<strong>Length Validation</strong>",id:"length-validation",level:5},{value:"<strong>Flattening Strategy</strong>",id:"flattening-strategy",level:5},{value:"<strong>Contiguous Layout</strong>",id:"contiguous-layout",level:5},{value:"\ud83d\udd04 Deserialization/Decoding Flow",id:"-deserializationdecoding-flow",level:3},{value:"Memory Efficiency Benefits",id:"memory-efficiency-benefits",level:3},{value:"Cache Storage Data Block (CSDB) Design",id:"cache-storage-data-block-csdb-design",level:2},{value:"Overview",id:"overview",level:3},{value:"Structure and Purpose",id:"structure-and-purpose",level:3},{value:"Core Fields and Memory Layout",id:"core-fields-and-memory-layout",level:4},{value:"Cache Types",id:"cache-types",level:4},{value:"Format &amp; Encoding",id:"format--encoding",level:3},{value:"Differences Between In-Memory and Distributed Caching",id:"differences-between-in-memory-and-distributed-caching",level:3},{value:"Optimizations &amp; Features",id:"optimizations--features",level:3}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"data-format-for-permanent--cache-storage",children:"Data Format for Permanent & Cache Storage"})}),"\n",(0,t.jsx)(n.p,{children:"In this section we will go through the data-formats which is at the hear of online-feature-store, it's inspired form other storage efficient formats like parquet & arrow, but custom made to deliver in constraint environment. The two key data-formats are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"PSDB"})," - Permanent Storage Data Block used wile storing data in ScyllaDB"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CSDB"})," - Cache Storage Data Block used while storing data in DragonflyDB or Redis, optimal for KV"]}),"\n",(0,t.jsx)(n.li,{}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"psdb-permanent-storage-data-block-format",children:"PSDB (Permanent Storage Data Block) Format"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"PSDB"})," format is a compact, versioned, and schema-aware binary layout used to store feature groups efficiently for ML inference. It supports multiple datatypes (strings, booleans, fixed-size vectors), versioning, TTL, and metadata encoding in a compact header."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-structure-overview",children:"\ud83e\uddf1 Structure Overview"}),"\n",(0,t.jsx)(n.p,{children:"Each PSDB block is composed of multiple byte sections:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Permanent Storage Data Block Anatomy",src:i(340).A+"",width:"1854",height:"1102"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Byte"}),(0,t.jsx)(n.th,{children:"Bits"}),(0,t.jsx)(n.th,{children:"Field"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"0-1"}),(0,t.jsx)(n.td,{children:"0-15"}),(0,t.jsx)(n.td,{children:"Feature Schema Version"}),(0,t.jsx)(n.td,{children:"Version for tracking schema changes (additions/deletions) in feature group"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"2-6"}),(0,t.jsx)(n.td,{children:"16-55"}),(0,t.jsx)(n.td,{children:"Expiry Timestamp"}),(0,t.jsx)(n.td,{children:"Encoded as a compact representation, ~513 days max"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"7"}),(0,t.jsx)(n.td,{children:"56-59"}),(0,t.jsx)(n.td,{children:"Layout Version"}),(0,t.jsx)(n.td,{children:"Used to ensure backward compatibility with layout format changes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"7"}),(0,t.jsx)(n.td,{children:"60-62"}),(0,t.jsx)(n.td,{children:"Compression Type"}),(0,t.jsx)(n.td,{children:"3-bit field specifying compression algorithm"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"7-8"}),(0,t.jsx)(n.td,{children:"63-67"}),(0,t.jsx)(n.td,{children:"Data Type"}),(0,t.jsx)(n.td,{children:"5-bit field split across bytes 7 and 8"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"8"}),(0,t.jsx)(n.td,{children:"68-71"}),(0,t.jsx)(n.td,{children:"Bool Last Valid Bit"}),(0,t.jsx)(n.td,{children:"4-bit field for last valid boolean bit"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"supported-data-types",children:"Supported Data Types"}),"\n",(0,t.jsx)(n.h4,{id:"scalar-types",children:"Scalar Types"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Container"}),(0,t.jsx)(n.th,{children:"Size"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"FP32"}),", ",(0,t.jsx)(n.code,{children:"FP16"}),", ",(0,t.jsx)(n.code,{children:"FP8E4M3"}),", ",(0,t.jsx)(n.code,{children:"FP8E5M2"})]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[]float32"})}),(0,t.jsx)(n.td,{children:"4/2/1/1 bytes"}),(0,t.jsx)(n.td,{children:"Floating point numbers"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"Int32"}),", ",(0,t.jsx)(n.code,{children:"Int16"}),", ",(0,t.jsx)(n.code,{children:"Int8"})]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[]int32"})}),(0,t.jsx)(n.td,{children:"4/2/1 bytes"}),(0,t.jsx)(n.td,{children:"Signed integers"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"Uint32"}),", ",(0,t.jsx)(n.code,{children:"Uint16"}),", ",(0,t.jsx)(n.code,{children:"Uint8"})]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[]uint32"})}),(0,t.jsx)(n.td,{children:"4/2/1 bytes"}),(0,t.jsx)(n.td,{children:"Unsigned integers"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"FP64"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[]float64"})}),(0,t.jsx)(n.td,{children:"8 bytes"}),(0,t.jsx)(n.td,{children:"Double precision float"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Int64"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[]int64"})}),(0,t.jsx)(n.td,{children:"8 bytes"}),(0,t.jsx)(n.td,{children:"64-bit signed integer"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Uint64"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[]uint64"})}),(0,t.jsx)(n.td,{children:"8 bytes"}),(0,t.jsx)(n.td,{children:"64-bit unsigned integer"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"String"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[]string"})}),(0,t.jsx)(n.td,{children:"Variable"}),(0,t.jsx)(n.td,{children:"Pascal-style strings"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Bool"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[]uint8"})}),(0,t.jsx)(n.td,{children:"Bit-packed"}),(0,t.jsx)(n.td,{children:"Boolean values"})]})]})]}),"\n",(0,t.jsx)(n.h4,{id:"vector-types",children:"Vector Types"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Container"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"FP32Vector"}),", ",(0,t.jsx)(n.code,{children:"FP16Vector"}),", etc."]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[][]float32"})}),(0,t.jsx)(n.td,{children:"2D slices of floating point"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"Int32Vector"}),", ",(0,t.jsx)(n.code,{children:"Int16Vector"}),", etc."]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[][]int32"})}),(0,t.jsx)(n.td,{children:"2D slices of signed integers"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"Uint32Vector"}),", ",(0,t.jsx)(n.code,{children:"Uint16Vector"}),", etc."]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[][]uint32"})}),(0,t.jsx)(n.td,{children:"2D slices of unsigned integers"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"FP64Vector"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[][]float64"})}),(0,t.jsx)(n.td,{children:"2D slices of doubles"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Int64Vector"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[][]int64"})}),(0,t.jsx)(n.td,{children:"2D slices of 64-bit signed"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Uint64Vector"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[][]uint64"})}),(0,t.jsx)(n.td,{children:"2D slices of 64-bit unsigned"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"StringVector"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[][]string"})}),(0,t.jsx)(n.td,{children:"2D slices of strings"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"BoolVector"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[][]uint8"})}),(0,t.jsx)(n.td,{children:"2D slices of bit-packed bools"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"-encoding-for-scalar-feature-type",children:"\ud83d\udce6 Encoding for Scalar Feature Type"}),"\n",(0,t.jsx)(n.h4,{id:"1--string-feature-group-variable-length-encoding-using-pascal",children:"1. \ud83d\udd21 String Feature Group (Variable Length Encoding using Pascal)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Max string length: ",(0,t.jsx)(n.strong,{children:"65536"})]}),"\n",(0,t.jsxs)(n.li,{children:["Format:\n",(0,t.jsx)(n.img,{alt:"PSDB String encoding",src:i(9432).A+"",width:"1488",height:"204"})]}),"\n",(0,t.jsxs)(n.li,{children:["Deserialization:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Read length prefixes"}),"\n",(0,t.jsxs)(n.li,{children:["Extract string bytes using ",(0,t.jsx)(n.code,{children:"StrLenX"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"2--boolean-feature-group-bit-packed",children:"2. \ud83d\udfe9 Boolean Feature Group (Bit-Packed)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Saves space using bit-level packing."}),"\n",(0,t.jsxs)(n.li,{children:["Encoding:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Raw: 1 byte per feature"}),"\n",(0,t.jsx)(n.li,{children:"Bit-packed: 1 bit per boolean"}),"\n",(0,t.jsxs)(n.li,{children:["Additional index (",(0,t.jsx)(n.code,{children:"bool last idx"}),") stores where the last bit resides"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Format:\n",(0,t.jsx)(n.img,{alt:"PSDB Bool encoding",src:i(1729).A+"",width:"1120",height:"712"})]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"3--fixed-length-feature-group",children:"3. \ud83d\udccf Fixed-Length Feature Group"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["For fixed-size vectors (",(0,t.jsx)(n.code,{children:"n"})," bytes each)"]}),"\n",(0,t.jsxs)(n.li,{children:["Format:\n",(0,t.jsx)(n.img,{alt:"PSDB Fixed Length Datatype encoding",src:i(9106).A+"",width:"1122",height:"202"})]}),"\n",(0,t.jsx)(n.li,{children:"Efficient for dense numeric features like float32, int64, etc."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"4-compression",children:"4. Compression"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"TypeNone (0)"}),": Raw storage"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"TypeZSTD (1)"}),": Compressed using Zstandard"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Compression is opportunistic. During serialization, if compressed size is not smaller, PSDB falls back to uncompressed format. It keeps the read/high througput path use less CPU cycles. Also only data part of PSDB is compressed allowing decompression only if block has a valid TTL"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-encoding-for-vector-types",children:"\ud83e\uddec Encoding for Vector Types"}),"\n",(0,t.jsx)(n.h4,{id:"conceptual-overview",children:"Conceptual Overview"}),"\n",(0,t.jsx)(n.p,{children:"PSDB encodes vector data by flattening multi-dimensional arrays into a single contiguous byte buffer while preserving the ability to reconstruct the original vector boundaries."}),"\n",(0,t.jsx)(n.h4,{id:"vector-length-metadata",children:"Vector Length Metadata"}),"\n",(0,t.jsx)(n.p,{children:"Each feature group maintains metadata about vector dimensions in the Feature Registry. For example, if a feature group has:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"fg1:\n  version-2:\n    features:\n      f1: { vector_len: 6, default: [bytes] }\n      f2: { vector_len: 3, default: [bytes] }\n  version-1:\n    features:\n      f1: { vector_len: 6, default: [bytes] }\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Feature f1 with vector_len: 6"}),"\n",(0,t.jsx)(n.li,{children:"Feature f2 with vector_len: 3"}),"\n",(0,t.jsx)(n.li,{}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This means:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"f1"})," contains vectors of exactly 6 elements each"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"f2"})," contains vectors of exactly 3 elements each"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"encoding-process",children:"Encoding Process"}),"\n",(0,t.jsx)(n.h5,{id:"input-structure",children:(0,t.jsx)(n.strong,{children:"Input Structure"})}),"\n",(0,t.jsx)(n.p,{children:"The serializer receives vector data as 2D slices where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Outer dimension represents different feature instances/entities"}),"\n",(0,t.jsx)(n.li,{children:"Inner dimension represents the vector elements for each instance"}),"\n"]}),"\n",(0,t.jsx)(n.h5,{id:"length-validation",children:(0,t.jsx)(n.strong,{children:"Length Validation"})}),"\n",(0,t.jsx)(n.p,{children:"Before encoding, PSDB validates that each vector's actual length matches the declared vector_len from the feature metadata. This ensures data integrity and enables efficient decoding."}),"\n",(0,t.jsx)(n.h5,{id:"flattening-strategy",children:(0,t.jsx)(n.strong,{children:"Flattening Strategy"})}),"\n",(0,t.jsx)(n.p,{children:"Vectors are serialized in row-major order (also called C-style order):"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"All elements of the first vector are written consecutively"}),"\n",(0,t.jsx)(n.li,{children:"Followed by all elements of the second vector"}),"\n",(0,t.jsx)(n.li,{children:"And so on..."}),"\n"]}),"\n",(0,t.jsx)(n.h5,{id:"contiguous-layout",children:(0,t.jsx)(n.strong,{children:"Contiguous Layout"})}),"\n",(0,t.jsx)(n.p,{children:"The resulting byte buffer contains all vector elements placed end-to-end without gaps or separators. The decoder can reconstruct vector boundaries because it knows:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The data type size (e.g., 4 bytes for float32), from feature registry"}),"\n",(0,t.jsx)(n.li,{children:"The vector length for each position, from feature registry"}),"\n",(0,t.jsx)(n.li,{children:"The total number of vectors, from feature registry"}),"\n",(0,t.jsxs)(n.li,{children:["In case of ",(0,t.jsx)(n.code,{children:"variable length"})," length is encoded into the data, like for ",(0,t.jsx)(n.code,{children:"String"})," data-type"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-deserializationdecoding-flow",children:"\ud83d\udd04 Deserialization/Decoding Flow"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Extract version"})," from first 2 bytes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Look up schema"})," from etcd using the version."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Determine feature shapes"})," (e.g., vector lengths)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Slice and decode"})," data from byte buffer accordingly."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"memory-efficiency-benefits",children:"Memory Efficiency Benefits"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"No Padding"}),": Elements are packed tightly without alignment padding"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"No Delimiters"}),": Vector boundaries are implicit, not stored explicitly"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cache Friendly"}),": Sequential memory access patterns during encoding/decoding"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Minimal Metadata"}),": Only vector lengths are stored separately, not per-element"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"cache-storage-data-block-csdb-design",children:"Cache Storage Data Block (CSDB) Design"}),"\n",(0,t.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"The Cache Storage Data Block (CSDB) is a compact binary data format that encapsulates serialized data blocks for multiple feature groups. It is designed to support both in-memory and distributed caching of deserialized PSDB (Permanent Storage Data Block) content, optimizing for speed, deduplication, and minimal memory overhead."}),"\n",(0,t.jsx)(n.h3,{id:"structure-and-purpose",children:"Structure and Purpose"}),"\n",(0,t.jsx)(n.p,{children:"Each CSDB contains a mapping of feature group IDs (FG IDs) to deserialized PSDBs. For distributed systems, this structure is flattened into a serialized byte slice. The CSDB supports layout versioning for backward compatibility and negative caching for feature groups with no associated data."}),"\n",(0,t.jsx)(n.h4,{id:"core-fields-and-memory-layout",children:"Core Fields and Memory Layout"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"type CacheStorageDataBlock struct {\n    // 8-byte aligned map pointer\n    FGIdToDDB map[int]*DeserializedPSDB // offset: 0\n\n    // 24-byte slice (ptr, len, cap)\n    serializedCSDB []byte // offset: 8\n\n    // 4-byte fields\n    TTL uint32 // offset: 32\n\n    // 1-byte fields\n    layoutVersion uint8     // offset: 36\n    cacheType     CacheType // offset: 37\n    // 2 bytes padding to maintain 4-byte alignment\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"The structure is memory-aligned for optimal performance:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Pointers and slices are 8-byte aligned"}),"\n",(0,t.jsxs)(n.li,{children:["Smaller fields (like ",(0,t.jsx)(n.code,{children:"uint8"}),") are grouped and padded to avoid false sharing"]}),"\n",(0,t.jsx)(n.li,{children:"This layout ensures efficient use of CPU caches during access"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"cache-types",children:"Cache Types"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"In-Memory Cache"}),": Uses the ",(0,t.jsx)(n.code,{children:"FGIdToDDB"})," map directly and avoids serialization unless explicitly requested."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Distributed Cache"}),": Stores a serialized binary format in ",(0,t.jsx)(n.code,{children:"serializedCSDB"}),", which is deserialized lazily when required."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"format--encoding",children:"Format & Encoding"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"CSDB Binary Layout"}),": Serialized CSDBs follow this compact format:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"[LayoutVersion (1 byte)][FGID (2 bytes)][DataLen (2 bytes)][Data ...]   \u2192 repeated per feature group\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["FGID and DataLen are encoded as ",(0,t.jsx)(n.code,{children:"uint16"})]}),"\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"DataLen == 0"}),", it denotes a negative cache (no data available for that FG)"]}),"\n",(0,t.jsx)(n.li,{children:"The data section contains the PSDB header and either compressed or uncompressed data"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This layout allows fast scanning and partial deserialization for selected FG IDs, making it optimal for large-scale caching systems."}),"\n",(0,t.jsx)(n.h3,{id:"differences-between-in-memory-and-distributed-caching",children:"Differences Between In-Memory and Distributed Caching"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Aspect"}),(0,t.jsx)(n.th,{children:"In-Memory CSDB"}),(0,t.jsx)(n.th,{children:"Distributed CSDB"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Storage Format"}),(0,t.jsx)(n.td,{children:"Live Go objects (map[int]*DeserializedPSDB)"}),(0,t.jsxs)(n.td,{children:["Serialized byte buffer (",(0,t.jsx)(n.code,{children:"[]byte"}),")"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Deserialization"}),(0,t.jsx)(n.td,{children:"Performed on-demand using offset map"}),(0,t.jsx)(n.td,{children:"Performed on-demand using offset map"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Compression"}),(0,t.jsx)(n.td,{children:"Optional during serialization"}),(0,t.jsx)(n.td,{children:"Typically enabled to reduce payload size"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Usage Pattern"}),(0,t.jsx)(n.td,{children:"Fast lookup in active process memory"}),(0,t.jsx)(n.td,{children:"Cross-node cache sharing and persistence"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Memory Overhead"}),(0,t.jsx)(n.td,{children:"Higher (due to live objects)"}),(0,t.jsx)(n.td,{children:"Lower (compact representation)"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"optimizations--features",children:"Optimizations & Features"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Partial FG ID Fetch"}),": When only a subset of FG IDs is needed, CSDB avoids unnecessary deserialization of other IDs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Negative Caching"}),": FG IDs with no data are encoded with ",(0,t.jsx)(n.code,{children:"DataLen=0"}),", saving space and avoiding repeated lookups."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Offset-Length Map"}),": During deserialization, FGID to offset+length pairs are cached internally for efficient random access."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Versioning Support"}),": Layout version is stored as the first byte to enable format upgrades while maintaining backward compatibility."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Diagram below explains how compute cycles are saved by partial de-compression."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"CSDB Partial Decompression",src:i(4040).A+"",width:"2292",height:"828"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}}}]);