"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4797],{762:(e,t,a)=>{a.d(t,{A:()=>r});const r=a.p+"assets/images/bms-7399e8796d2cd24617c432518ce3f312.png"},3306:e=>{e.exports=JSON.parse('{"permalink":"/BharatMLStack/blog/episodic-memory-for-agents","editUrl":"https://github.com/Meesho/BharatMLStack/tree/main/docs/blog/bharatmlstack-history/episodic-memory-for-agents/index.md","source":"@site/blog/bharatmlstack-history/episodic-memory-for-agents/index.md","title":"Beyond Vector RAG: Building Agent Memory That Learns From Experience.","description":"Current agent memory is just search. We built an episodic memory system that tracks outcomes, forms causal links, extracts reasoning heuristics, and actually learns from failure \u2014 without retraining the model.","date":"2026-02-19T00:00:00.000Z","tags":[{"inline":true,"label":"ai-agents","permalink":"/BharatMLStack/blog/tags/ai-agents"},{"inline":true,"label":"memory","permalink":"/BharatMLStack/blog/tags/memory"},{"inline":true,"label":"architecture","permalink":"/BharatMLStack/blog/tags/architecture"},{"inline":true,"label":"llm","permalink":"/BharatMLStack/blog/tags/llm"},{"inline":true,"label":"episodic-memory","permalink":"/BharatMLStack/blog/tags/episodic-memory"}],"readingTime":11.61,"hasTruncateMarker":true,"authors":[{"name":"Adarsha Das","title":"Senior Architect @ Meesho","url":"https://github.com/a0d00kc","imageURL":"https://github.com/a0d00kc.png","key":"adarsha","page":null}],"frontMatter":{"title":"Beyond Vector RAG: Building Agent Memory That Learns From Experience.","description":"Current agent memory is just search. We built an episodic memory system that tracks outcomes, forms causal links, extracts reasoning heuristics, and actually learns from failure \u2014 without retraining the model.","slug":"episodic-memory-for-agents","authors":["adarsha"],"date":"2026-02-19T00:00:00.000Z","tags":["ai-agents","memory","architecture","llm","episodic-memory"]},"unlisted":false,"nextItem":{"title":"LLM Inference Optimization Techniques: Engineering Sub-Second Latency at Scale","permalink":"/BharatMLStack/blog/llm-inference-optimization-sub-sec-latency"}}')},4043:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>m});var r=a(3306),n=a(4848),i=a(8453);const s={title:"Beyond Vector RAG: Building Agent Memory That Learns From Experience.",description:"Current agent memory is just search. We built an episodic memory system that tracks outcomes, forms causal links, extracts reasoning heuristics, and actually learns from failure \u2014 without retraining the model.",slug:"episodic-memory-for-agents",authors:["adarsha"],date:new Date("2026-02-19T00:00:00.000Z"),tags:["ai-agents","memory","architecture","llm","episodic-memory"]},o=void 0,c={authorsImageUrls:[void 0]},m=[];function l(e){const t={img:"img",p:"p",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.img,{alt:"BharatMLStack",src:a(762).A+"",width:"1396",height:"460"}),'\nEvery agent framework on the market will tell you their agents "have memory." What they mean is: they have a vector database.']}),"\n",(0,n.jsx)(t.p,{children:"They chunk text, embed it, store it, and retrieve whatever looks similar at query time. This works for document Q&A. It fails the moment you expect an agent to recall what happened last time, learn from a mistake, or avoid repeating a failed approach."}),"\n",(0,n.jsx)(t.p,{children:"We are trying to built something different. An episodic memory system where a frozen LLM \u2014 same weights, no retraining \u2014 produces increasingly better decisions over time because the memory feeding it context is continuously evolving."}),"\n",(0,n.jsx)(t.p,{children:"Then we tested it. The results surprised us."})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>s,x:()=>o});var r=a(6540);const n={},i=r.createContext(n);function s(e){const t=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);