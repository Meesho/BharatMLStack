"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4424],{248:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"inferflow/v1.0.0/architecture","title":"Architecture","description":"Inferflow is part of BharatMLStack, a graph-driven feature retrieval and model inference orchestration engine built in Go. It eliminates the need for custom feature retrieval code by using configurable DAG topologies to dynamically resolve entity relationships, fetch features from the Online Feature Store, and orchestrate model scoring \u2014 all driven by configuration stored in etcd.","source":"@site/docs/inferflow/v1.0.0/architecture.md","sourceDirName":"inferflow/v1.0.0","slug":"/inferflow/v1.0.0/architecture","permalink":"/BharatMLStack/inferflow/v1.0.0/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/Meesho/BharatMLStack/tree/main/docs/docs/inferflow/v1.0.0/architecture.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Architecture","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"v1.0.0","permalink":"/BharatMLStack/inferflow/v1.0.0"},"next":{"title":"Key Functionalities","permalink":"/BharatMLStack/inferflow/v1.0.0/functionalities"}}');var i=r(4848),s=r(8453);const o={title:"Architecture",sidebar_position:1},l="BharatMLStack - Inferflow",c={},d=[{value:"Overview",id:"overview",level:2},{value:"High-Level Architecture",id:"high-level-architecture",level:2},{value:"Core Components",id:"core-components",level:2},{value:"1. gRPC Server",id:"1-grpc-server",level:3},{value:"2. DAG Topology Executor",id:"2-dag-topology-executor",level:3},{value:"3. Component Types",id:"3-component-types",level:3},{value:"4. ComponentMatrix \u2014 The 2D Result Matrix",id:"4-componentmatrix--the-2d-result-matrix",level:3},{value:"How the matrix evolves through the DAG",id:"how-the-matrix-evolves-through-the-dag",level:4},{value:"Matrix structure",id:"matrix-structure",level:4},{value:"5. Configuration Management (etcd)",id:"5-configuration-management-etcd",level:3},{value:"6. External Integrations",id:"6-external-integrations",level:3},{value:"Online Feature Store (OnFS)",id:"online-feature-store-onfs",level:4},{value:"Predator (Model Serving)",id:"predator-model-serving",level:4},{value:"Numerix (Compute Engine)",id:"numerix-compute-engine",level:4},{value:"Kafka (Inference Logging)",id:"kafka-inference-logging",level:4},{value:"Request Flow",id:"request-flow",level:2},{value:"Observability",id:"observability",level:2},{value:"Metrics (StatsD / Telegraf)",id:"metrics-statsd--telegraf",level:3},{value:"Logging",id:"logging",level:3},{value:"Deployment",id:"deployment",level:2},{value:"Docker",id:"docker",level:3},{value:"Supported Environments",id:"supported-environments",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Target Users",id:"target-users",level:2},{value:"Benefits",id:"benefits",level:2},{value:"Contributing",id:"contributing",level:2},{value:"Community &amp; Support",id:"community--support",level:2},{value:"License",id:"license",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"bharatmlstack---inferflow",children:"BharatMLStack - Inferflow"})}),"\n",(0,i.jsxs)(n.p,{children:["Inferflow is part of ",(0,i.jsx)(n.strong,{children:"BharatMLStack"}),", a graph-driven feature retrieval and model inference orchestration engine built in ",(0,i.jsx)(n.strong,{children:"Go"}),". It eliminates the need for custom feature retrieval code by using configurable DAG topologies to dynamically resolve entity relationships, fetch features from the Online Feature Store, and orchestrate model scoring \u2014 all driven by configuration stored in ",(0,i.jsx)(n.strong,{children:"etcd"}),"."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"In a typical ML serving pipeline, every new model requires bespoke code to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fetch features from multiple entities (user, product, user x category, etc.)"}),"\n",(0,i.jsx)(n.li,{children:"Infer intermediate entity relationships (e.g., extract category from product to fetch user x category data)"}),"\n",(0,i.jsx)(n.li,{children:"Orchestrate one or more model inference calls"}),"\n",(0,i.jsx)(n.li,{children:"Handle I/O, batching, and error propagation"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Inferflow abstracts all of this behind a ",(0,i.jsx)(n.strong,{children:"config-driven DAG executor"}),". Given a ",(0,i.jsx)(n.code,{children:"model_config_id"})," and context entities (e.g., ",(0,i.jsx)(n.code,{children:"userId"}),", ",(0,i.jsx)(n.code,{children:"productIds"}),"), it:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Loads a pre-defined feature retrieval and inference graph from etcd"}),"\n",(0,i.jsx)(n.li,{children:"Executes the graph to resolve entity relationships dynamically"}),"\n",(0,i.jsx)(n.li,{children:"Retrieves features from the Online Feature Store (OnFS) in parallel"}),"\n",(0,i.jsx)(n.li,{children:"Calls model serving endpoints (Predator) and compute services (Numerix)"}),"\n",(0,i.jsx)(n.li,{children:"Returns scored results as a structured response"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"high-level-architecture",children:"High-Level Architecture"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Inferflow Architecture - DAG Topology Executor",src:r(7748).A+"",width:"2036",height:"1212"})}),"\n",(0,i.jsxs)(n.p,{children:["The diagram shows the internal DAG structure of Inferflow's topology executor. gRPC APIs (Pair, Point, Slate) feed into the DAG, where ",(0,i.jsx)(n.strong,{children:"Feature Init"})," bootstraps the ComponentMatrix. Feature components (FS User, FS Product, FS Region, FS User Cat, FS Region Scat) fetch features from ",(0,i.jsx)(n.strong,{children:"OnFS"})," in parallel and populate columns in the shared ",(0,i.jsx)(n.strong,{children:"2D Result Matrix"}),". Model components (Model A, Model B) call ",(0,i.jsx)(n.strong,{children:"Predator"})," for inference, and compute components call ",(0,i.jsx)(n.strong,{children:"Numerix"})," for operations like reranking. The entire DAG topology is driven by config loaded from ",(0,i.jsx)(n.strong,{children:"etcd"}),"."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,i.jsx)(n.h3,{id:"1-grpc-server",children:"1. gRPC Server"}),"\n",(0,i.jsxs)(n.p,{children:["Inferflow exposes its APIs via a gRPC server, with HTTP health endpoints multiplexed on the same port using ",(0,i.jsx)(n.strong,{children:"cmux"}),". The server provides:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Inferflow API"})," \u2014 ",(0,i.jsx)(n.code,{children:"RetrieveModelScore"}),": entity-based feature retrieval and scoring"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Predict API"})," \u2014 ",(0,i.jsx)(n.code,{children:"InferPointWise"}),", ",(0,i.jsx)(n.code,{children:"InferPairWise"}),", ",(0,i.jsx)(n.code,{children:"InferSlateWise"}),": structured inference with targets, pairs, and slates"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-dag-topology-executor",children:"2. DAG Topology Executor"}),"\n",(0,i.jsxs)(n.p,{children:["The heart of Inferflow. Each model configuration defines a ",(0,i.jsx)(n.code,{children:"component_dependency"})," map that describes a Directed Acyclic Graph (DAG) of components."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Execution model:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Uses ",(0,i.jsx)(n.strong,{children:"Kahn's algorithm"})," for topological ordering"]}),"\n",(0,i.jsxs)(n.li,{children:["Components at the same level run ",(0,i.jsx)(n.strong,{children:"concurrently"})," in goroutines"]}),"\n",(0,i.jsxs)(n.li,{children:["All components share a mutable ",(0,i.jsx)(n.code,{children:"ComponentMatrix"})," (rows = entity IDs, columns = features/scores)"]}),"\n",(0,i.jsxs)(n.li,{children:["DAG topologies are ",(0,i.jsx)(n.strong,{children:"cached"})," using Murmur3 hashing with Ristretto cache"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Validation:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Cycle detection via in-degree analysis"}),"\n",(0,i.jsxs)(n.li,{children:["Component existence verification against the ",(0,i.jsx)(n.code,{children:"ComponentProvider"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-component-types",children:"3. Component Types"}),"\n",(0,i.jsx)(n.p,{children:"Inferflow defines four types of DAG components:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Component"}),(0,i.jsx)(n.th,{children:"Role"}),(0,i.jsx)(n.th,{children:"External Dependency"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"FeatureInitComponent"})}),(0,i.jsxs)(n.td,{children:["Root node \u2014 initializes the ",(0,i.jsx)(n.code,{children:"ComponentMatrix"})," with entity IDs and schema"]}),(0,i.jsx)(n.td,{children:"None"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"FeatureComponent"})}),(0,i.jsx)(n.td,{children:"Fetches features from the Online Feature Store for a specific entity type"}),(0,i.jsx)(n.td,{children:"OnFS (gRPC)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"PredatorComponent"})}),(0,i.jsx)(n.td,{children:"Calls model serving endpoints for inference scoring"}),(0,i.jsx)(n.td,{children:"Predator / Helix (gRPC)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"NumerixComponent"})}),(0,i.jsx)(n.td,{children:"Calls compute engine for operations like reranking"}),(0,i.jsx)(n.td,{children:"Numerix (gRPC)"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"4-componentmatrix--the-2d-result-matrix",children:"4. ComponentMatrix \u2014 The 2D Result Matrix"}),"\n",(0,i.jsx)(n.p,{children:"The ComponentMatrix is a shared, mutable 2D data structure that flows through the entire DAG. Every component reads from and writes to this matrix, progressively building a complete feature + score row for each entity."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"DAG Execution &amp; 2D Matrix Flow",src:r(3066).A+"",width:"672",height:"778"})}),"\n",(0,i.jsx)(n.h4,{id:"how-the-matrix-evolves-through-the-dag",children:"How the matrix evolves through the DAG"}),"\n",(0,i.jsx)(n.p,{children:"The diagram above illustrates the three execution phases and how the 2D matrix grows at each stage:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Phase 1 \u2014 Feature Retrieval"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"init"})," node creates an empty matrix with one row per target entity ID. Feature components then execute \u2014 first the top-level entities (entity A, entity B) fetch their features from OnFS and populate their columns (shown as colored blocks). Derived entities (entity C, D, E) resolve their keys from the already-populated columns and add more feature columns. At this point the matrix contains all feature data, with each color representing features from a different entity."]}),"\n",(0,i.jsxs)(n.p,{children:["The right side of the diagram shows the matrix being ",(0,i.jsx)(n.strong,{children:"decomposed"})," \u2014 feature columns from different entities are separated into per-model input groups, selecting only the features each model needs."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Phase 2 \u2014 Model Invocation"})}),"\n",(0,i.jsxs)(n.p,{children:["Model X and Model Y each receive their decomposed feature slices, call ",(0,i.jsx)(n.strong,{children:"Predator"})," for inference, and write score columns back into the matrix (shown as new colored columns appended to the right). Multiple models can run in parallel if they don't depend on each other's outputs."]}),"\n",(0,i.jsx)(n.p,{children:"The scores are then decomposed again to prepare inputs for the compute stage."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Phase 3 \u2014 Numerix Compute"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"Score Comb"})," node takes score columns from both models, calls ",(0,i.jsx)(n.strong,{children:"Numerix"})," for a final compute operation (e.g., score combination, reranking), and writes the final score column (shown in dark red) into the matrix. The result is a complete row per entity with all features and all scores."]}),"\n",(0,i.jsx)(n.h4,{id:"matrix-structure",children:"Matrix structure"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Property"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Rows"})}),(0,i.jsx)(n.td,{children:"One per target entity ID (e.g., each product being scored)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"String columns"})}),(0,i.jsx)(n.td,{children:"Human-readable values used in responses"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Byte columns"})}),(0,i.jsx)(n.td,{children:"Binary-encoded feature values used for model inputs"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Column naming"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"entity_label:feature_group:feature_name"})})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Each component only reads the columns it needs and writes to its own columns, enabling safe concurrent execution across independent branches of the DAG."}),"\n",(0,i.jsxs)(n.p,{children:["For slate-based APIs, a companion ",(0,i.jsx)(n.code,{children:"SlateData"})," structure holds per-slate matrices and scores, with ",(0,i.jsx)(n.code,{children:"slate_target_indices"})," mapping slates to rows in the main matrix."]}),"\n",(0,i.jsx)(n.h3,{id:"5-configuration-management-etcd",children:"5. Configuration Management (etcd)"}),"\n",(0,i.jsx)(n.p,{children:"Model configurations are stored in etcd and hot-reloaded via watchers:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Config paths"}),": ",(0,i.jsx)(n.code,{children:"/config/inferflow/services/"}),", ",(0,i.jsx)(n.code,{children:"/model-config"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Watch mechanism"}),": etcd watchers trigger ",(0,i.jsx)(n.code,{children:"ReloadModelConfigMapAndRegisterComponents"})," on any change"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"On reload"}),": Updates ",(0,i.jsx)(n.code,{children:"ConfigMap"}),", re-initializes feature schemas, and re-registers DAG components"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This means new models or configuration changes go live ",(0,i.jsx)(n.strong,{children:"without redeployment"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"6-external-integrations",children:"6. External Integrations"}),"\n",(0,i.jsx)(n.h4,{id:"online-feature-store-onfs",children:"Online Feature Store (OnFS)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["gRPC client calling ",(0,i.jsx)(n.code,{children:"FeatureService.RetrieveFeatures"})]}),"\n",(0,i.jsx)(n.li,{children:"Batched retrieval with configurable batch size and deadline"}),"\n",(0,i.jsxs)(n.li,{children:["Auth via ",(0,i.jsx)(n.code,{children:"CALLER_ID"})," and ",(0,i.jsx)(n.code,{children:"CALLER_TOKEN"})," metadata"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"predator-model-serving",children:"Predator (Model Serving)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Uses ",(0,i.jsx)(n.code,{children:"helix-client"})," for model inference"]}),"\n",(0,i.jsxs)(n.li,{children:["Supports ",(0,i.jsx)(n.strong,{children:"percentage-based traffic routing"})," across multiple model endpoints"]}),"\n",(0,i.jsx)(n.li,{children:"Configurable calibration and batch sizing"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"numerix-compute-engine",children:"Numerix (Compute Engine)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Uses ",(0,i.jsx)(n.code,{children:"helix-client"})," Numerix client"]}),"\n",(0,i.jsxs)(n.li,{children:["RPC: ",(0,i.jsx)(n.code,{children:"NumerixService.Compute"})," with entity score data"]}),"\n",(0,i.jsx)(n.li,{children:"Used for compute operations like reranking"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"kafka-inference-logging",children:"Kafka (Inference Logging)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Async inference log publishing using ",(0,i.jsx)(n.code,{children:"segmentio/kafka-go"})]}),"\n",(0,i.jsxs)(n.li,{children:["Supports ",(0,i.jsx)(n.strong,{children:"Proto"}),", ",(0,i.jsx)(n.strong,{children:"Arrow"}),", and ",(0,i.jsx)(n.strong,{children:"Parquet"})," serialization formats"]}),"\n",(0,i.jsxs)(n.li,{children:["Configurable sampling via ",(0,i.jsx)(n.code,{children:"LoggingPerc"})," and user-based daily sampling"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"request-flow",children:"Request Flow"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"1. Client sends gRPC request with model_config_id + entity IDs\n                    \u2502\n2. Load ModelConfig from etcd-backed ConfigMap\n                    \u2502\n3. Adapt proto request \u2192 ComponentRequest\n   (build ComponentMatrix with entity schema)\n                    \u2502\n4. Resolve DAG topology from component_dependency config\n                    \u2502\n5. Execute DAG (Kahn's algorithm, concurrent):\n   \u2502\n   \u251c\u2500 FeatureInitComponent: populate matrix with entity IDs + schema\n   \u2502\n   \u251c\u2500 FeatureComponents (parallel): fetch features from OnFS \u2192 fill matrix columns\n   \u2502\n   \u251c\u2500 PredatorComponent: build feature payloads from matrix \u2192 call model \u2192 write scores\n   \u2502\n   \u2514\u2500 NumerixComponent: read scores from matrix \u2192 call compute \u2192 write final scores\n                    \u2502\n6. Build response from matrix columns per ResponseConfig\n                    \u2502\n7. (Optional) Async Kafka logging of inference features and scores\n                    \u2502\n8. Return gRPC response to client\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"observability",children:"Observability"}),"\n",(0,i.jsx)(n.h3,{id:"metrics-statsd--telegraf",children:"Metrics (StatsD / Telegraf)"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Metric"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"inferflow.retrievemodelscore.request.total"})}),(0,i.jsx)(n.td,{children:"Total RetrieveModelScore requests"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"inferflow.retrievemodelscore.latency"})}),(0,i.jsx)(n.td,{children:"End-to-end latency"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"inferflow.retrievemodelscore.batch.size"})}),(0,i.jsx)(n.td,{children:"Batch size per request"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"predict.infer.request.total"})}),(0,i.jsx)(n.td,{children:"Total Predict API requests"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"predict.infer.latency"})}),(0,i.jsx)(n.td,{children:"Predict API latency"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"inferflow.component.execution.total"})}),(0,i.jsx)(n.td,{children:"Per-component execution count"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"inferflow.component.execution.latency"})}),(0,i.jsx)(n.td,{children:"Per-component latency"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"inferflow.component.execution.error"})}),(0,i.jsx)(n.td,{children:"Component-level errors"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"inferflow.component.feature.count"})}),(0,i.jsx)(n.td,{children:"Feature count per component"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"inferflow.external.api.request.total"})}),(0,i.jsx)(n.td,{children:"External API call count"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"inferflow.external.api.latency"})}),(0,i.jsx)(n.td,{children:"External API latency"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"inferflow.component.inmemorycache.request.total"})}),(0,i.jsx)(n.td,{children:"Cache hit/miss total"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"inferflow.component.inmemorycache.miss"})}),(0,i.jsx)(n.td,{children:"Cache misses"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"inferflow.logging.kafka_sent"})}),(0,i.jsx)(n.td,{children:"Kafka log messages sent"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"logging",children:"Logging"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Structured JSON logging via ",(0,i.jsx)(n.strong,{children:"zerolog"})]}),"\n",(0,i.jsx)(n.li,{children:"Configurable log levels"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"deployment",children:"Deployment"}),"\n",(0,i.jsx)(n.h3,{id:"docker",children:"Docker"}),"\n",(0,i.jsx)(n.p,{children:"Inferflow ships as a multi-stage Docker image:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Builder"}),": Go 1.19 Alpine with optional Kafka support (librdkafka)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Runtime"}),": Debian 10 slim"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Build command"}),": ",(0,i.jsx)(n.code,{children:'go build -tags musl -ldflags "-extldflags -static" -o server cmd/${module}/main.go'})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"supported-environments",children:"Supported Environments"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Kubernetes (K8s)"}),"\n",(0,i.jsx)(n.li,{children:"Google Kubernetes Engine (GKE)"}),"\n",(0,i.jsx)(n.li,{children:"Amazon EKS"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsx)(n.p,{children:"All configuration is driven via environment variables (loaded by Viper) and etcd. No config files are required at deployment time."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"target-users",children:"Target Users"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"User"}),(0,i.jsx)(n.th,{children:"Role"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Data Scientists"}),(0,i.jsx)(n.td,{children:"Define model configs and feature retrieval graphs via config \u2014 no code needed"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"ML Engineers"}),(0,i.jsx)(n.td,{children:"Onboard new models by updating etcd config; manage DAG topologies"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Backend Developers"}),(0,i.jsx)(n.td,{children:"Integrate via gRPC SDKs for real-time scoring in application services"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Platform Engineers"}),(0,i.jsx)(n.td,{children:"Deploy, scale, and monitor Inferflow clusters"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"benefits",children:"Benefits"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No-code feature retrieval"})," \u2014 new models need only a config change, not custom code"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feature consistency"})," \u2014 same graph-driven retrieval ensures identical features across experiments"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Faster iteration"})," \u2014 experiment with new models in minutes, not days"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Concurrent execution"})," \u2014 DAG components run in parallel for minimal latency"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hot reloading"})," \u2014 model config changes via etcd go live without redeployment"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-API support"})," \u2014 PointWise, PairWise, and SlateWise inference patterns out of the box"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Production-grade"})," \u2014 built in Go with gRPC, designed for millions of QPS"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"contributing",children:"Contributing"}),"\n",(0,i.jsxs)(n.p,{children:["We welcome contributions from the community! Please see our ",(0,i.jsx)(n.a,{href:"https://github.com/Meesho/BharatMLStack/blob/main/CONTRIBUTING.md",children:"Contributing Guide"})," for details on how to get started."]}),"\n",(0,i.jsx)(n.h2,{id:"community--support",children:"Community & Support"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Discord"}),": Join our ",(0,i.jsx)(n.a,{href:"https://discord.gg/XkT7XsV2AU",children:"community chat"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Issues"}),": Report bugs and request features on ",(0,i.jsx)(n.a,{href:"https://github.com/Meesho/BharatMLStack/issues",children:"GitHub Issues"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Email"}),": Contact us at ",(0,i.jsx)(n.a,{href:"mailto:ml-oss@meesho.com",children:"ml-oss@meesho.com"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"license",children:"License"}),"\n",(0,i.jsxs)(n.p,{children:["BharatMLStack is open-source software licensed under the ",(0,i.jsx)(n.a,{href:"https://github.com/Meesho/BharatMLStack/blob/main/LICENSE.md",children:"BharatMLStack Business Source License 1.1"}),"."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{align:"center",children:(0,i.jsx)("strong",{children:"Built with \u2764\ufe0f for the ML community from Meesho"})}),"\n",(0,i.jsx)("div",{align:"center",children:(0,i.jsx)("strong",{children:"If you find this useful, \u2b50\ufe0f the repo \u2014 your support means the world to us!"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},3066:(e,n,r)=>{r.d(n,{A:()=>t});const t=r.p+"assets/images/v1.0.0-inferflow-dag-matrix-0f13b51422587e6099cf4ee783844db1.png"},7748:(e,n,r)=>{r.d(n,{A:()=>t});const t=r.p+"assets/images/v1.0.0-inferflow-arch-bce54b3b4f7d3be68fa22dc204529f53.png"},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>l});var t=r(6540);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);